# Halogen Specification

Halogen is used to transform [Noir Music Format](https://github.com/canidlogic/libnmf) (NMF) files with a quantum basis of 96 quanta per quarter note into one of the fixed quantum bases in Hz.

NMF files produced by [Noir](https://github.com/canidlogic/noir) always have a quantum basis of 96 quanta per quarter note.  This allows rhythm to be notated independently of any specific tempo, as is the usual convention in music notation.  However, sequencer programs require timing information to be specified according to a fixed control rate expressed in Hz.  Halogen is able to take NMF files with a basis of 96 quanta per quarter note and apply a tempo map to transform them into any of the fixed quantum bases supported by NMF:  [1, 1024] Hz, 44,100 Hz, or 48,000 Hz.

## Syntax

    ./halogen.pl tempo.map 60 < input.nmf > output.nmf

Halogen takes two arguments.  The first is the path to a _tempo map,_ the format of which is described later in this specification.  The second is the fixed rate in Hz to use as a quantum basis in the output NMF file.  The fixed rate must be either 44100, 48000, or an integer in range [1, 1024].

Halogen then reads an NMF file from standard input.  This input NMF file must have a quantum basis of 96 quanta per quarter note.  (All NMF files generated by the `noir` program will have this quantum basis.)  A new NMF file is generated that has the same number of sections and notes as the original NMF file.  However, the quantum basis of this NMF file will match the fixed rate given as the second program argument, and the time offsets and durations of all note records and section records will be adjusted according to the tempo map.  The new NMF file is then written to standard output.

No grace notes (notes with negative durations) will be present in the output NMF file.  Halogen will correctly time each grace note and convert them into regular note records with positive durations in the output NMF.  Cues (notes with zero duration) will be preserved, but their time offsets will be adjusted to fit the tempo map.

## Tempo map

The **tempo map** is a script in [Shastina](https://github.com/canidlogic/libshastina) format that determines how the quantum basis of 96 quanta per quarter note maps to a fixed quantum basis in Hz.

The result of interpreting a tempo map script is a **beat sequence.**  A beat sequence has the following components:

1. Finite sequence of one or more **beats**
2. **Repeat count** integer in range [1, n] where n is number of beats
3. **Pickup duration** in microseconds (zero or greater)

The finite sequence of beats is extended to infinite range by looping the last _m_ beats, where _m_ is the repeat count.  In the common case where you want a single tempo across the whole performance, you just need to define a single beat and set a repeat count of one.

The pickup duration is added to every time offset in the output NMF, except for section offsets of zero.  A non-zero pickup duration is required when there are grace notes at the start of the performance that would otherwise have a negative time offset.  It is also useful for adding silence at the start of the performance.

Each beat has three pieces of information:

1. Quanta count at 96 quanta per quarter basis
2. Beat duration in microseconds
3. Grace note duration in microseconds

These three pieces of information are each integer values that must be greater than zero.  However, the grace note duration is also allowed the special value of zero, meaning it is undefined.  An error occurs if a grace note is defined for any beat where the grace note duration is undefined.

Once Halogen has built the complete beat sequence from the tempo map script, Halogen is able to perform the conversion into the fixed-rate quantum basis.  Halogen always computes time offsets and durations in microseconds, and then rounds to the nearest cycle at the fixed control rate passed as a program argument.  Rounding is always down, except durations greater than zero that would round down to zero cycles instead round up to one cycle.

### Header

The tempo map begins with a **header** that looks like this:

    %halogen 1.0;

More specifically, the first four entities parsed from the Shastina script must be the following:

1. `BEGIN_META`
2. `META_TOKEN` with case-sensitive value `halogen`
3. `META_TOKEN` with version number
4. `END_META`

The only version supported by this specification is the version with an exact string match of `1.0` (no leading or trailing zeroes).  The version number is intended so that future versions can have backwards compatibility.

### Data types

Halogen scripts support the following data types:

1. Null
2. Integer
3. Float
4. Beat string

**Null** is a special data type that only contains a single "null" value.  This is used to represent "no data."

**Integers** may be in range [-9007199254740991, 9007199254740991].  The maximum is `(2^53)-1` which is the largest integer value exactly represented within a double-precision floating-point number.  Integers may be used anywhere a float is required, in which case the integers will be automatically promoted to an equivalent float value.

**Floats** are double-precision floating-point numbers that may have any finite value.  (Non-finite values such as infinity and NaN are not supported in Halogen.)

**Beat strings** are finite sequences of zero or more beats, where each beat has a quanta count, an integer duration in microseconds, and an integer grace note duration.

### Interpreter state

The Halogen script interpreter has the usual Shastina state components of an **interpreter stack** and a **namespace** for variables and constants.  Both the interpreter stack and namespace may store values of any data type.  Variables and constants share the same namespace, and names are case-sensitive sequences of ASCII alphanumerics and underscores where the first character is not a decimal digit and the total length is in range [1, 31].  The interpreter stack must be empty at the end of the Halogen script.

The script interpreter also has a **grace register** that stores either an integer value greater than zero or null.  It is initially null.  Certain operations refer to the grace register to determine what grace note length should be recorded in beats.  If the grace register has a null value, a special grace note length of zero will be recorded by this operations within beats, and an error occurs if a grace note occurs during any beat that has a grace note length of zero.  The rationale behind the grace register is that the grace note duration does not change frequently, so the register makes it easy to just set the duration once and forget about it.

Finally, the script interpreter has three registers for storing the results of the script interpretation.  The **beat string register** stores the beat string that determines the finite sequence of beats in the resulting beat sequence.  The **repeat count register** stores the repeat count that determines how the beat string is looped.  The **pickup register** stores the duration of the initial pickup in microseconds.

All three result registers start out with null values.  The only state of the registers that matters is the state at the end of the script interpretation.  At this point, none of the three registers may hold null values, and the repeat count must be less than or equal to the number of beats in the beat string within the beat string register.

### Shastina entities

Following the header, only the following Shastina entities are supported within a Halogen script:

- `EOF`
- `NUMERIC`
- `VARIABLE`
- `CONSTANT`
- `ASSIGN`
- `GET`
- `BEGIN_GROUP`
- `END_GROUP`
- `ARRAY`
- `OPERATION`

The **EOF entity** `|;` stops the script interpretation, and must appear once within the script.  Everything after the EOF entity is ignored.

**Numeric entities** push integer or float literals onto the interpreter stack.  If the entity contains either a period `.` or an exponent letter `E` or `e`, then it will push a float literal.  Else, it will push an integer literal.

Integer literals begin with an optional sign `+` or `-`, followed by a non-empty sequence of up to sixteen decimal digits.  The value must be in the integer range noted in the earlier section on data types.

Float literals have the following structure:

1. Sign `+` or `-`
2. Primary sequence of up to sixteen decimal digits
3. Fraction consisting of a period `.` and zero up to sixteen decimal digits
4. Exponent consisting of `E` or `e` followed by an integer literal

All four components of this structure are optional.  However, there must be a `.` or `E` or `e` somewhere for the literal to be interpreted as a float literal, and there must be at least one decimal digit in either (2) or (3).  Parsing the float literal must result in a finite value or there will be an error.

**Variable and constant entities** are used to define and manipulate variables and constants in the namespace in the usual Shastina style.  The format of variable and constant names was defined earlier in the section on interpreter state.

**Grouping entities** temporarily hide what is on the stack and ensure exactly one element is on the interpreter stack at the end of the group, in the usual Shastina fashion.

**Array entities** push an integer on the interpreter stack with the count of array elements.

**Operation entities** perform operations using the interpreter stack to pass parameters and receive results.  The supported operations are defined in the following sections.  The syntax for operations has the name of the operation in the middle, the input parameters to the operation that are popped off the interpreter stack to the left, and the output parameters that are pushed onto the interpreter stack to the right.  Within the input parameter and result lists, the top of the stack is always the rightmost element.

### Core operations

The following operations provide basic interpreter stack manipulation:

    [x:any] dup [x:any] [x:any]
    [x:any] pop -

The `dup` operation duplicates whatever is on top of the stack.  The `pop` operation removes whatever is on top of the stack.

    - null [x:null]

The `null` operation pushes the special null value on top of the interpreter stack.

### Arithmetic operations

The following operations provide basic arithmetic:

    [a:int|float] [b:int|float] add [c:int|float]
    [a:int|float] [b:int|float] sub [c:int|float]
    [a:int|float] [b:int|float] mul [c:int|float]
    [a:int|float] [b:int|float] div [c:float]

Each of these arithmetic operations takes two input parameters `a` and `b` and pushes the result `a OP b` where `OP` is one of the basic arithmetic operations.  The result will be an integer if both input parameters were integers and the result is within integer range.  Else, the result will be a float.  However, the `div` operation always produces floating-point results.

The following operations perform bounding:

    [v1:int|float] ... [vn:int|float] [n:int] max [m:int|float]
    [v1:int|float] ... [vn:int|float] [n:int] min [m:int|float]

Both of these operations take an array of one or more integers and floats.  They produce a result which is either the minimum or maximum of all the values in this array.  The type of the result will be an integer only if _all_ input array elements were integers.  Otherwise, it will be a float.

To force a conversion to integer, use the following operation:

    [v:int|float] int [r:int]

If the input parameter is an integer, this operation just returns the integer as-is.  Otherwise, it floors a floating-point value (rounds down towards negative infinity) and returns the integer conversion.  An error occurs if the rounded value is outside of the integer range documented in the section on data types.

To compute the duration of a beat from a given beats per minute (bpm) value, use the following operation:

    [bpm:float] bpm [dur:int]

The input to this operation must be a float value that is greater than zero.  The result is an integer duration in microseconds that is greater than zero and approximates the given bpm value as closely as possible.  The `bpm` operation is equivalent to the following:

    [60000000 =bpm div int, 1] max

where `=bpm` is the floating-point `bpm` parameter value.

### Beat string operations

To create beat strings of up to one beat, use the following operations:

                         - z [str:beats]
    [quanta:int] [dur:int] b [str:beats]

The `z` operation creates an empty beat string containing no beats.  The `b` operation creates a beat string with a single beat.  The single beat occupies the given number of `quanta` within the quantum basis of 96 quanta per quarter note, and it lasts for `dur` microseconds.  Both of these input values must be integers greater than zero.  The grace note duration in the beat is copied from the current value of the grace register.

To create a beat string representing a gradual tempo change, use the following operation:

    [bc:int] [bq:int] [d1:int] [d2:int] tr [str:beats]

The `bc` value is the total number of beats within the resulting beat string, which must be an integer value one or greater.  Each beat within the generated beat string occupies `bq` quanta within the quantum basis of 96 quanta per quarter note.  The first beat in the beat string lasts for `d1` microseconds, which must be an integer greater than zero.  The durations of any remaining beats in the beat string will be smoothly interpolated such that the beat _after_ the last beat in the beat string would have the duration `d2` microseconds, which must be greater than zero.  The grace note duration for each beat in the resulting string is copied from the current value of the grace register.

Note that the tempo in a beat string generated by `tr` will never actually reach the tempo implied by `d2`.  That tempo would have been reached if the beat string continued one beat longer.  This system allows multiple `tr` beat strings to be connected smoothly.  It also means that after a `tr` ramp where you want to end up in a steady tempo implied by `d2`, you must somehow include another beat after the last beat of the ramp to set the new tempo.

The `b` and `tr` operations both determine the grace note durations of all generated beats by the current value of the grace register.  You can set the grace register with the following operation:

    [dur:int|null] grace -

`dur` is the integer duration of grace notes in microseconds, or null meaning the grace note duration is undefined.  If an integer value is given, it must be greater than zero and specify the length in microseconds of each grace note.  The null value is the initial value of the register, and this undefined value may be reset at any time by passing a null value to `grace`.

It is acceptable for beats within beat strings to be assigned undefined grace note duration.  However, if any grace notes occur for beats where the grace note duration is undefined, an error occurs.

To determine the total length in quanta of a beat string, use the following operation:

    [src:beats] qlen [result:int]

The `result` is an integer sum of all the beat quanta values within the beat string.  Zero is returned if the beat string is empty.  Note that this is _not_ the number of beats within a beat string.  Even if a beat string has only one beat in it, `qlen` may return a value greater than one, because it is counting the total of all quanta covered by beats within the string.

To determine the total duration in microseconds of a beat string, use the following operation:

    [src:beats] dur [result:int]

The `result` is an integer sum of all the microsecond durations of beats within the beat string.

Existing beat strings can be concatenated into a new beat string with the following operation:

    [s1:beats] ... [sn:beats] [n:int] concat [result:beats]

The result contains all the beat strings in the input array concatenated together one after another, with `s1` first and `sn` last.  If `n` is one, then the single beat string is returned as-is.  If `n` is zero, an empty beat string with no beats is returned.

It is also possible to generate a new beat string by repeating an existing beat string a given number of times:

    [src:beats] [r:int] rep [result:beats]

The result beat string will be `src` repeated `r` times, where `r` must be an integer zero or greater.  If zero, an empty beat string is produced.  If one, the original beat string is returned.  If greater than one, it specifies the number of repetitions.

You can also extract a subrange of an existing beat string:

    [src:beats] [qstart:int] [qstop:int] slice [result:beats]

`qstart` must be an integer zero or greater, `qstop` must be an integer greater than or equal to `qstart`, and `qstop` must be less than or equal to the quanta length of `src` that would be returned by `qlen`.  The `result` will be a new beat string that contains quanta from the `src` beat string starting at quanta offset `qstart` and proceeding up to but excluding quanta offset `qstop`.  If `qstop` is equal to `qstart`, the resulting beat string will be empty.

The `slice` operation might end up with partial beats at the start and/or end, because the slice positions are measured in quanta offsets rather than beat offsets.  Partial beats will contain only those quanta that are within the slice range.  The duration in microseconds of the beat will then be adjusted so that each quantum within the partial beat still has approximately the same duration as each quantum within the full beat.

All duration values within a beat string can be scaled with the following operation:

    [src:beats] [s1:float] [s2:float] scale [result:beats]

The `src` string is unmodified.  `s1` is the amount to scale the first beat's duration (if the source string is not empty), and `s2` is the amount that the beat after the last beat in the string would be scaled.  Scaling values are smoothly interpolated across the string.  Scaling values must be greater than zero.  Scaled beat durations will be at least one, so there are considerable rounding artifacts if an extremely tiny scaling value is used.

A non-empty beat string can be extended or shrunk to fill a specific number of quanta by the following operation:

    [src:beats] [qtotal:int] qfill [result:beats]

The `src` is any beat string that has at least one beat.  `qtotal` is the number of quanta to fill, which must be zero or greater.  The resulting beat string will have a `qlen` of exactly `qtotal` quanta.  It is generated by repeating the source beat string until it is greater than or equal to `qtotal` in quanta length, and then slicing that result so its quanta length exactly equals `qtotal`.  `qfill` is equivalent to the following:

    =src (=qtotal (=src qlen) div int 1 add) rep 0 =qtotal slice

where `=src` is the `src` beat string, and `=qtotal` is the `qtotal` count of quanta.  This operation is especially useful for filling the rest of an NMF section and bringing the beat string to the starting quanta offset of a desired NMF section.

A non-empty beat string can also be scaled to fill a specific total duration in microseconds by the following operation:

    [src:beats] [total:int] filldur [result:beats]

The `src` is any beat string that has at least one beat.  `total` is the total desired duration in microseconds, which must be greater than zero.  All the beat durations in the beat string will be scaled by a constant scaling value _s_ such that the resulting duration is as close to `total` microseconds as possible.  `filldur` is equivalent to the following:

    =src (=total (=src dur) div) dup scale

where `=src` is the `src beat string, and `=total` is the desired `total` duration in microseconds.  This operation is especially useful for speeding up or slowing down the whole performance so that it fills a desired amount of time.

### Section operations

To read the quanta offset of a given section index within the NMF file, use the following operation

    [i:int] offset [result:int]

`i` is the index of the section, which must be greater than or equal to zero and less than the total number of sections in the NMF file.  `result` is the offset of that section in quanta from the start of the performance.

To define a beat string with a quarter note at 120 bpm for all quanta at the start of section 2 up to but excluding the start of section 3, you can use the following:

    (96 120 bpm b) (3 offset) (2 offset) sub qfill

### Output register operations

You can set values in the output registers with the following operations:

    [b:beats|null] store_beats  -
    [r:int|null  ] store_repeat -
    [d:int|null  | store_pickup -

These three operations set the values in the beat string register, repeat count register, and pickup duration register, respectively.  These registers start out with null values at the beginning of the script.  The only register state that matters is the state at the end of the script.

At the end of the script, the beat string register must be non-null and the repeat count must be a non-null integer at least one and less than the total number of beats in the beat string register.  The pickup register at the end of interpretation must hold an integer value that is zero or greater.
